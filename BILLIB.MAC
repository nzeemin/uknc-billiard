	.TITLE	BILLIB

;------------------------------------------------------------------------------

.MACRO	PUSH	RR
	MOV	RR,-(SP)
.ENDM
.MACRO	POP	RR
	MOV	(SP)+,RR
.ENDM

;------------------------------------------------------------------------------

SCRTOP=100000		; Начало экрана, косвенный адрес для УКНЦ

;------------------------------------------------------------------------------

	.CSECT

; Процедура для вызова из Паскаля: подготовка игрового экрана
; procedure SCGAME; external;
SCGAME::
	MOV	#GAMESC, R1		; Строка для подготовки игрового экрана
	CALL	PRINT
	CALL	PAUSE
	RETURN
; Процедура для вызова из Паскаля: очистка экрана перед выходом
; procedure SCEXIT; external;
SCEXIT::
	MOV	#EXITSC, R1		; Строка очистки экрана перед выходом
	CALL	PRINT
	CALL	PAUSE
	RETURN
GAMESC:	; Строка подготовки игрового экрана
	.BYTE	033,246,62	; Формат экрана 40x24
	.BYTE	033,240,62	; Цвет символа
	.BYTE	033,241,60	; Цвет знакоместа
	.BYTE	033,242,60	; Цвет фона
	.BYTE	14		; Clear screen
	.BYTE	0
EXITSC:	; Строка очистки экрана перед выходом
	.BYTE	33,246,061	; Формат экрана 80x24
	.BYTE	33,240,67	; Цвет символа
	.BYTE	33,241,61	; Цвет знакоместа 1
	.BYTE	33,242,61	; Цвет фона 1
	.BYTE	14		; Очистить экран
	.BYTE	0
	.EVEN

; Подпрограмма: Печать строки: R1 = адрес строки, строка завершается 0; портит R0
; После завершения R1 указывает на байт следующий за 0
PRINT:
10$:	MOVB	(R1)+, R0	; Конец строки?
	BEQ	RETN		; да => выходим
20$:	TSTB	@#177564	; Источник канала 0 готов?
	BPL	20$		; нет => ждём
	MOV	R0, @#177566	; передаём символ в канал 0
	BR	10$

; Подпрограмма: пауза после очистки экрана чтобы ПП закончил работу
PAUSE:	; Pause to let PPU finish the previous commands
	MOV	#177777, R5
1$:	NOP
	SOB	R5, 1$
RETN:	RETURN

;------------------------------------------------------------------------------

; Процедура для вызова из Паскаля: рисования спрайта шара
; procedure DRBALL(X,Y:integer); external;
DRBALL::
	MOV	4(SP), R0		; X
	MOV	R0, R3
	BIC	#177770, R3		; 0..7 - смещение
	MUL	#57., R3		; на длину спрайта
	ADD	#BALLS, R3		; R3 = адрес спрайта
	MOV	2(SP), R1		; Y
	MUL	#120, R1		; Y * на длину строки
	ASH	#-3, R0			; X разделить на 8
	ADD	R0, R1
	ADD	#SCRTOP, R1	
	MOV	#176640, R4		; Адрес порта адреса косвенной записи УКНЦ
	MOV	#19., R2		; строк спрайта
10$:
; 1
	CLR	R0
	BISB	(R3)+, R0		; берём 8 пикселов
	MOV	R1, (R4)		;   пишем адрес
	XOR	R0, @#176642		;   пишем в ВОЗУ УКНЦ
	INC	R1			; к следующей колонке
; 2
	CLR	R0
	BISB	(R3)+, R0		; берём 8 пикселов
	MOV	R1, (R4)		;   пишем адрес
	XOR	R0, @#176642		;   пишем в ВОЗУ УКНЦ
	INC	R1			; к следующей колонке
; 3
	CLR	R0
	BISB	(R3)+, R0		; берём 8 пикселов
	MOV	R1, (R4)		;   пишем адрес
	XOR	R0, @#176642		;   пишем в ВОЗУ УКНЦ
;
	ADD	#<120-2>, R1		; к следующей строке
	SOB	R2, 10$
;
	MOV	(SP), 4(SP)
	ADD	#4, SP
	RETURN

; Процедура для вызова из Паскаля: рисование символа 8x9 по произвольным координатам
; procedure DRCHAR(X,Y:integer; C:char); external;
DRCHAR::
	MOV	6(SP), R3		; X
	MOV	R3, R0
	BIC	#177770, R0		; 0..7 - смещение
3$:	MOV	R0, @#<20$+2>		; заменяем параметр команды ASH
	MOV	4(SP), R1		; Y
	MUL	#120, R1		; Y * на длину строки
	ASH	#-3, R3			; X разделить на 8
	ADD	R3, R1			; R1 = адрес на экране
	ADD	#SCRTOP, R1	
	MOV	2(SP), R3		; берем символ
	SUB	#60, R3			; с чего начинается знакогенератор
	MOV	#9., R2			; количество строк
	MUL	R2, R3			; на длину символа в байтах
	ADD	#FONTD9, R3		; R3 = адрес символа
	MOV	#176640, R4		; Адрес порта адреса косвенной записи УКНЦ
10$:
	CLR	R0
	BISB	(R3)+, R0		; берём 8x1 пикселов
20$:	ASH	#0, R0			; изменяемый параметр команды!
	PUSH	R0
	BIC	#177400, R0
	MOV	R1, (R4)		;   пишем адрес
	XOR	R0, @#176642		;   пишем в ВОЗУ УКНЦ
	INC	R1			; на колонку вправо
	POP	R0
	SWAB	R0
	BIC	#177400, R0
	MOV	R1, (R4)		;   пишем адрес
	XOR	R0, @#176642		;   пишем в ВОЗУ УКНЦ
	ADD	#<120-1>, R1		; к следующей строке
	SOB	R2, 10$
;
	MOV	(SP), 6(SP)
	ADD	#6, SP
	RETURN

;------------------------------------------------------------------------------

.INCLUDE /SPRITE.MAC/

;------------------------------------------------------------------------------
	.END
